Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:
```
Вывод:
<nil>
false

Функция Foo() возвращает nil типа *os.PathError, результат мы сравниваем с nil типа nil, поэтому они не равны.

Можно исправить. 1 вариант:
func Foo() (err *os.PathError) {
	err = nil
	return
}

2 вариант, вызвать в main():
fmt.Println(err.(*os.PathError) == nil)
___

Интерфейсы используются для описания ожидаемого поведения типа. Применяются для внедрения зависимостей.
Интерфейсы разрешают вызывающей стороне привязываться не к реализации, а только к определенному поведению (набору методов). 
Особенность Go в том, что в отличие от ООП языков в нем нет явного указания, какой интерфейс реализует наша структура. 
Достаточно только удовлетворять набору и сигнатуре методов интерфейса - это называют утиной типизацией.
Пр:
type Debtor interface {
    WrOffDebt() error
}
Все структуры, имеющие данный набор методов интерфейса (в нашем случае - WrOffDebt), удовлетворяют этому интерфейсу.
Структура — это сгруппированный в один объект набор полей/свойств.

Внутри интерфейс состоит из значения и типа. Два значения интерфейса равны,
если они имеют одинаковые конкретные значения и идентичные динамические типы, или если оба равны nil.
Значение интерфейса равно nil, только если внутреннее значение и тип не заданы, (nil, nil). 
___

Пустой интерфейс - это интерфейс, не требущий реализации, значит, по сути, в переменную такого типа можно присвоить любое значение: структуру, примитив, сложный тип.
var emI interface{}

Пустой интерфейсный тип не описывает методы. У него нет правил. И поэтому любой объект удовлетворяет пустому интерфейсу.

```
